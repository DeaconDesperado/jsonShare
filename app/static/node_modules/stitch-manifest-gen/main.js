"use strict";

// TODO(blixt): Remove the dependency on this package as it's humongous.
var npm = require('npm');

var async = require('async');
var fs = require('fs');
var glob = require('glob');
var path = require('path');
var readInstalled = require('read-installed');
var semver = require('semver');
var _ = require('underscore');

var fallbackLang = 'en';

function allBridges(compatBridgeSets) {
  var allBridges = [];
  _.each(compatBridgeSets, function(bridgeSet) {
    for (var bridge in bridgeSet) {
      var version = bridgeSet[bridge];
      allBridges.push({
        name: bridge,
        major: semver(version).major
      });
    }
  });
  return _.uniq(allBridges);
}

exports.computeCompatibility = function(allCompatibilities) {
  if (allCompatibilities.length < 1) {
    throw 'No compatibility fields found. Could not compute spotlet compatibility';
  }

  var allCompatBridgeDeps = _.pluck(allCompatibilities, 'bridge_dependencies');
  var bridges = allBridges(allCompatBridgeDeps);
  var bridgeDependencies = {};

  for (var i = 0; i < bridges.length; i++) {
    var bridge = bridges[i];

    var compatVersion = semver(bridge.major.toString() + '.0.0');
    for (var j = 0; j < allCompatBridgeDeps.length; j++) {
      var bridgeDeps = allCompatBridgeDeps[j];
      if (_.size(bridgeDeps) > 0) {
        var bridgeDep = bridgeDeps[bridge.name];
        if (bridgeDep && semver(bridgeDep).major === bridge.major) {
          if (semver.lt(compatVersion, bridgeDep)) {
            compatVersion = semver(bridgeDep);
          }
        } else {
          compatVersion = null;
          break;
        }
      }
    }

    if (compatVersion) {
      bridgeDependencies[bridge.name] = compatVersion.version;
    }
  }

  var devices = allCompatibilities[0].devices;

  // Compute device compatibility
  for (i = 1; i < allCompatibilities.length; ++i) {
    devices = _.intersection(
        devices,
        allCompatibilities[i].devices);
  }

  return {
    'bridge_dependencies': bridgeDependencies,
    'devices': devices
  };
};

exports.fetchCompatibilityFields = function(manifest) {
  var bridgeDependencies = manifest.BridgeDependencies;
  if (typeof bridgeDependencies === 'undefined') {
    bridgeDependencies = {};
  }

  var devices = manifest.SupportedDeviceClasses;
  if (typeof devices === 'undefined' || devices.length < 1) {
    devices = ['Desktop'];
  }

  return {
    'bridge_dependencies': bridgeDependencies,
    'devices': devices
  };
};

function getAllSpotifyConfigs(rootSpotifyConfig, callback) {
  var configs = [rootSpotifyConfig];
  npm.load({}, function(error, npm) {
    if (error) {
      callback(error, null);
      return;
    }

    glob(path.join(npm.dir, '/**/spotify.json'), function(error, files) {
      if (error) {
        callback(error, null);
        return;
      }

      for (var i = 0; i < files.length; i++) {
        configs.push(JSON.parse(fs.readFileSync(files[i], {encoding: 'utf8'})));
      }

      callback(null, configs);
    });
  });
}

exports.computeLangs = function(spotifyConfigs) {
  // Get a single list of all supported languages.
  var langs = spotifyConfigs.map(function(data) {
    return (data.SupportedLanguages || []).map(function(language) {
      return language.replace(/_/g, '-');
    });
  });

  var supportedLangs = _.union(_.flatten(langs, true));
  return supportedLangs;
}

exports.localizeAppProperties = function(property_name, langs) {
  var defaultValue = property_name;
  var dict = {};
  for (var i = 0; i < langs.length; i++) {
    var lang = langs[i];
    var lang_file = path.join(process.cwd(), lang + '.loc', 'strings', 'main.lang');
    if (fs.existsSync(lang_file)) {
      var strings = JSON.parse(fs.readFileSync(lang_file, {encoding: 'utf8'}));
      dict[lang] = strings[property_name] || defaultValue;
    } else {
      dict[lang] = defaultValue;
    }
  }
  return dict;
}

exports.fillDictionary = function(dict, langs) {
  var oldDict = dict;
  var defaultTerm = dict[fallbackLang] || dict[Object.keys(dict)[0]] || "";
  for (var i = 0; i < langs.length; i++) {
    var lang = langs[i];
    if (!(lang in dict)) {
      dict[lang] = defaultTerm;
    }
  }
  return dict;
}

function _loadConfigs(bundleRoot, callback) {
  var tasks = {
    packageInfo: function(callback) {
      readInstalled(bundleRoot, 0, null, callback);
    },

    spotify: function(callback) {
      // TODO(blixt): When removing npm dependency, make this simpler.
      async.waterfall([
        function(callback) {
          fs.readFile(path.join(bundleRoot, 'spotify.json'), {encoding: 'utf8'}, function(error, data) {
            callback(error, error ? null : JSON.parse(data));
          });
        },

        function(spotifyConfig, callback) {
          getAllSpotifyConfigs(spotifyConfig, callback);
        }
      ], callback);
    }
  };

  async.parallel(tasks, callback);
}

// TODO(blixt): Move into its own module.
function applicationManifest(packageInfo, manifest, spotifyConfigs) {
  // Get compatibility
  var compatFields = spotifyConfigs.map(exports.fetchCompatibilityFields);
  var compatibility = exports.computeCompatibility(compatFields);
  delete manifest.BridgeDependencies;
  delete manifest.SupportedDeviceClasses;
  manifest.BundleIdentifier = packageInfo.name;
  manifest.BundleVersion = packageInfo.version;
  manifest.BridgeDependencies = compatibility.bridge_dependencies;
  manifest.SupportedDeviceClasses = compatibility.devices;

  // Get all languages.
  var supportedLangs = exports.computeLangs(spotifyConfigs);

  // AppSupportedLanguages is the languages the app supports not including its frameworks.
  manifest.AppSupportedLanguages = manifest.SupportedLanguages;

  // Replace SupportedLanguages with computed languages.
  manifest.SupportedLanguages = supportedLangs;

  if (manifest.AppNameKey) {
    manifest.AppName = exports.localizeAppProperties(manifest.AppNameKey, supportedLangs);
    delete manifest.AppNameKey;
  } else {
    manifest.AppName = exports.fillDictionary(manifest.AppName, supportedLangs);
  }

  if (manifest.AppDescriptionKey) {
    manifest.AppDescription = exports.localizeAppProperties(manifest.AppDescriptionKey, supportedLangs);
    delete manifest.AppDescriptionKey;
  } else {
    manifest.AppDescription = exports.fillDictionary(manifest.AppDescription, supportedLangs);
  }

  // Inject the 1.x API.
  manifest.Dependencies = {'api': '1.0.0'};

  // If the package includes quickstart-spotify, rely on it to include the
  // essential JavaScript files, instead of the container injecting them.
  manifest.InjectScripts = !depends(packageInfo, 'quickstart-spotify', '>=0.1.0');

  // Determine whether the SPM app is using GLUE (which means we should not
  // inject the standard API stylesheets).
  manifest.InjectStylesheets = (
      !depends(packageInfo, 'glue') &&
      !depends(packageInfo, 'glue-cat') &&
      !depends(packageInfo, 'spotify-glue') &&
      !depends(packageInfo, 'spotify-glue-cat'));

  // ---- SPM reverse comp fields ----
  // Tell spackager not to validate languages - kickstart does
  manifest.SkipLanguageValidation = true;
  // Tell spackager not to validate unrequire - kickstart is one file already
  manifest.SkipUnrequireValidation = true;
  // Signal the app is an SpmApp
  manifest.SpmApp = true;

  // Add the SPM dependencies to manifest as SpmDependencies.
  if (packageInfo.dependencies) {
    manifest.SpmDependencies = formatDependencies(packageInfo.dependencies);
  }

  return manifest;
}

function formatDependencies(deps) {
  var result = {};
  for (var pkg in deps) {
    result[pkg] = deps[pkg].version;
  }
  return result;
}

/**
 * Returns true if there is any dependency on the specified package. Optionally
 * if a version is passed as well it will check against a specific version of
 * that package.
 * @param {Object} packageInfo Object containing package data.
 * @param {string} pkg The package name to look for.
 * @param {string=} opt_version A semver version that the dependency has to
 *     to match for this check to return true. This can be a range, such as
 *     ">=1.0.2 <2.1.2"
 * @returns {boolean}
 */
var depends = function(packageInfo, pkg, opt_version) {
  var deps = packageInfo.dependencies,
      depsVersion = deps && deps[pkg] && deps[pkg].version;

  if (!depsVersion) {
    // There is no dependency on the given package.
    return false;
  } else if (!opt_version) {
    // There is a dependency and we don't need to check the version.
    return true;
  }

  return semver.satisfies(depsVersion, opt_version);
};

function frameworkManifest(packageInfo, spotifyConfig) {
  spotifyConfig.Dependencies = spotifyConfig.LegacyDependencies;
  spotifyConfig.BundleIdentifier = packageInfo.name;
  spotifyConfig.BundleVersion = packageInfo.version;
  return spotifyConfig;
}

exports.computeManifest = function(bundleRoot, callback) {
  _loadConfigs(bundleRoot, function(error, data) {
    if (error) {
      callback(error, null);
      return;
    }

    try {
      var manifest = data.spotify[0];

      if (manifest.BundleType == 'Application') {
        callback(null, applicationManifest(data.packageInfo, manifest, data.spotify));
      } else {
        callback(null, frameworkManifest(data.packageInfo, manifest));
      }
    } catch (e) {
      callback(e, null);
    }
  });
};

exports.depends = depends;
